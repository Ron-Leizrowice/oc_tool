I am working on a windows app for extreme overclocking assistance, which allows the user to apply a variety of tweaks to improve system performance, and undo them.

I am using the Model-View-Update (MVU) pattern with the eframe and egui libraries to create the UI. The app will have a list of tweaks that the user can apply or revert, each with a switch or button to toggle the tweak on or off.

1. Tweaks will be applied either via registry edits, group policy edits, or powershell scripts.
2. Reversible tweaks (such as changing a registry key) will display a switch, one time tweaks (like processing idle tasks) will be a button.
3. Once a tweak has been run, it will be processed in the background, and display "applying" next to it. The switch or button should be greyed out and uninterruptable. 
4. Once a switch based tweak has been applied, the switch should toggle to on, and if it is reverted it should be toggled to off. If the tweak fails to apply or revert, the toggle should not transition.
5. When the program is started, it should check the state of the all the tweaks and set their switches accordingly.
6. If the user clicks multiple tweaks, they should be processed in a queue in the background.

```rust
// src/main.rs

mod actions;
mod errors;
mod tweaks;
mod widgets;
mod worker;

use std::sync::{atomic, Arc, Mutex, MutexGuard};

use actions::{initialize_all_tweaks, Tweak, TweakAction};
use eframe::{egui, App, Frame, NativeOptions};
use tracing::{debug, error, info, span, trace, warn, Level};
use tweaks::TweakId;

use crate::{
    actions::TweakStatus,
    worker::{TweakWorker, WorkerMessage},
};

struct MyApp {
    tweaks: Vec<Arc<Mutex<Tweak>>>,
    executor: TweakWorker,
}

impl MyApp {
    fn new(_cc: &eframe::CreationContext<'_>) -> Self {
        // Initialize tracing spans for better context
        let app_span = span!(Level::INFO, "App Initialization");
        let _app_guard = app_span.enter();

        info!("Initializing Overclocking Assistant application");

        // Initialize tweaks
        info!("Initializing tweaks...");
        let mut tweaks = initialize_all_tweaks();

        // Initialize tweak executor
        info!("Initializing tweak executor...");
        let executor = TweakWorker::new();

        // Initialize the current state of all tweaks
        info!("Checking initial state of all tweaks");
        for arc_tweak in &mut tweaks {
            let mut tweak = arc_tweak.lock().unwrap();
            match tweak.check_initial_state() {
                Ok(enabled) => {
                    info!(
                        "{:?} -> Initial state: {}",
                        tweak.id,
                        if enabled { "enabled" } else { "disabled" }
                    );
                    tweak.enabled.store(enabled, atomic::Ordering::SeqCst);
                    tweak.status = TweakStatus::Idle;
                }
                Err(e) => {
                    warn!("{:?} -> Initialization error: {}", tweak.id, e);
                    tweak.status = TweakStatus::Failed(format!("Initialization error: {}", e));
                }
            }
        }
        info!("Application initialization complete");
        Self { tweaks, executor }
    }

    fn select_tweak(&self, id: TweakId) -> MutexGuard<Tweak> {
        // Find the tweak by ID
        self.tweaks
            .iter()
            .find(|tweak| tweak.lock().unwrap().id == id)
            .expect("Received WorkerResult for unknown tweak.")
            .lock()
            .unwrap()
    }
}

impl App for MyApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut Frame) {
        // Poll for worker results
        loop {
            todo!()
        }

        // Draw the UI

        // Check for clicks
    }

    fn on_exit(&mut self, _gl: Option<&eframe::glow::Context>) {
        info!("Application is exiting. Sending shutdown message to executor.");
        // Send shutdown message to executor
        if let Err(e) = self.executor.sender.send(WorkerMessage::Shutdown) {
            error!(
                error = ?e,
                "Failed to send Shutdown message."
            );
        } else {
            debug!("Shutdown message sent to executor.");
        }
        // Optionally, wait for executor to finish
        info!("Shutdown process complete.");
    }
}

fn main() -> eframe::Result<()> {
    // Initialize tracing subscriber to enable logging with more detailed settings
    tracing_subscriber::fmt()
        .with_max_level(Level::DEBUG) // Set the maximum log level
        .with_target(false) // Optionally hide the log target (module path)
        .with_span_events(tracing_subscriber::fmt::format::FmtSpan::CLOSE) // Log when spans close
        .init();

    info!("Starting Overclocking Assistant...");

    // Configure eframe options as needed
    let options = NativeOptions::default();

    // Create a tracing span for the run_native call
    let run_span = span!(Level::INFO, "Run Native");
    run_span.in_scope(|| {
        trace!("Entering Run Native span.");
        eframe::run_native(
            "Overclocking Assistant",
            options,
            Box::new(|cc| {
                tracing::debug!("Creating MyApp instance.");
                Ok(Box::new(MyApp::new(cc)))
            }),
        )
    })
}
```

```rust
// src/worker.rs

use std::sync::{Arc, Mutex};

use crossbeam::channel::{Receiver, Sender};

use crate::{actions::Tweak, tweaks::TweakId};

#[derive(Clone, Debug)]
pub enum WorkerMessage {
    GetTweakInitialState { tweak: Arc<Mutex<Tweak>> },
    ApplyTweak { tweak: Arc<Mutex<Tweak>> },
    RevertTweak { tweak: Arc<Mutex<Tweak>> },
    Shutdown,
}

#[derive(Clone, Debug)]
pub enum WorkerResult {
    TweakCompleted {
        id: TweakId,
        success: bool,
        error: Option<String>,
    },
}

pub struct TweakWorker {
    pub sender: Sender<WorkerMessage>,
    pub receiver: Receiver<WorkerResult>,
}
```

```rust
// src/actions.rs

use std::sync::{atomic::AtomicBool, Arc, Mutex};

use anyhow::Error;

use crate::{
    tweaks::{fetch_tweak_method, TweakId, TweakMethod},
    widgets::TweakWidget,
};

/// Represents the current status of a tweak.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TweakStatus {
    Idle,
    Applying,
    Failed(String),
}

/// Represents a single tweak that can be applied to the system.
#[derive(Debug, Clone)]
pub struct Tweak {
    /// Unique identifier for the tweak.
    pub id: TweakId,
    /// Indicates whether the tweak is currently enabled.
    pub enabled: Arc<AtomicBool>,
    /// The status of the tweak (e.g., "Applied", "In Progress", "Failed").
    pub status: TweakStatus,
    /// The widget to use for each tweak
    pub widget: TweakWidget,
}

pub fn initialize_all_tweaks() -> Vec<Arc<Mutex<Tweak>>> {
    vec![
        Arc::new(Mutex::new(Tweak {
            id: TweakId::LargeSystemCache,
            enabled: Arc::new(AtomicBool::new(false)),
            status: TweakStatus::Idle,
            widget: TweakWidget::Switch,
        })),
        Arc::new(Mutex::new(Tweak {
            id: TweakId::SystemResponsiveness,
            enabled: Arc::new(AtomicBool::new(false)),
            status: TweakStatus::Idle,
            widget: TweakWidget::Switch,
        })),
        Arc::new(Mutex::new(Tweak {
            id: TweakId::DisableHWAcceleration,
            enabled: Arc::new(AtomicBool::new(false)),
            status: TweakStatus::Idle,
            widget: TweakWidget::Switch,
        })),
        Arc::new(Mutex::new(Tweak {
            id: TweakId::Win32PrioritySeparation,
            enabled: Arc::new(AtomicBool::new(false)),
            status: TweakStatus::Idle,
            widget: TweakWidget::Switch,
        })),
        Arc::new(Mutex::new(Tweak {
            id: TweakId::DisableCoreParking,
            enabled: Arc::new(AtomicBool::new(false)),
            status: TweakStatus::Idle,
            widget: TweakWidget::Switch,
        })),
        Arc::new(Mutex::new(Tweak {
            id: TweakId::SeLockMemoryPrivilege,
            enabled: Arc::new(AtomicBool::new(false)),
            status: TweakStatus::Idle,
            widget: TweakWidget::Switch,
        })),
        Arc::new(Mutex::new(Tweak {
            id: TweakId::UltimatePerformancePlan,
            enabled: Arc::new(AtomicBool::new(false)),
            status: TweakStatus::Idle,
            widget: TweakWidget::Switch,
        })),
    ]
}

/// Trait defining actions that can be performed on a tweak, such as checking if it's enabled,
/// applying the tweak, and reverting it.
pub trait TweakAction {
    /// Determines if the tweak is currently enabled.
    fn check_initial_state(&self) -> Result<bool, Error>;

    /// Applies the tweak.
    fn apply(&self) -> Result<(), Error>;

    /// Reverts the tweak to its default state.
    fn revert(&self) -> Result<(), Error>;
}

impl TweakAction for Tweak {
    /// Checks the current state of the tweak and updates the `enabled` field accordingly.
    /// This should only be run once when the application starts.
    fn check_initial_state(&self) -> Result<bool, Error> {
        match fetch_tweak_method(self.id) {
            TweakMethod::Registry(method) => {
                return method
                    .is_registry_tweak_enabled(self.id)
                    .map_err(Error::from)
            }
            TweakMethod::GroupPolicy(method) => {
                return method
                    .is_group_policy_tweak_enabled(self.id)
                    .map_err(Error::from)
            }
            TweakMethod::Powershell(method) => {
                return method
                    .is_powershell_script_enabled(self.id)
                    .map_err(Error::from)
            }
        };
    }

    /// Applies the tweak based on its method.
    fn apply(&self) -> Result<(), Error> {
        let result = match fetch_tweak_method(self.id) {
            TweakMethod::Registry(method) => {
                method.apply_registry_tweak(self.id).map_err(Error::from)
            }
            TweakMethod::GroupPolicy(method) => method
                .apply_group_policy_tweak(self.id)
                .map_err(Error::from),
            TweakMethod::Powershell(method) => {
                method.run_apply_script(self.id).map_err(Error::from)
            }
        };

        result
    }

    /// Reverts the tweak to its default state based on its method.
    fn revert(&self) -> Result<(), Error> {
        let result = match fetch_tweak_method(self.id) {
            TweakMethod::Registry(method) => {
                method.revert_registry_tweak(self.id).map_err(Error::from)
            }
            TweakMethod::GroupPolicy(method) => method
                .revert_group_policy_tweak(self.id)
                .map_err(Error::from),
            TweakMethod::Powershell(method) => method.run_undo_script(self.id).map_err(Error::from),
        };

        match &result {
            Ok(_) => {
                tracing::info!(
                    "{:?} -> Tweak reverted successfully, status set to idle.",
                    self.id
                );
            }
            Err(e) => {
                tracing::error!(
                    error = ?e,
                    "{:?} -> Failed to revert tweak.", self.id
                );
            }
        }

        result
    }
}
```

```rust
// src/widgets/mod.rs

pub mod button;
pub mod switch;
use std::{collections::HashMap, sync::LazyLock};

use crate::tweaks::TweakId;

/// Enum representing the different widget types for a tweak.
#[derive(Clone, Debug)]
pub enum TweakWidget {
    Switch,
    Button,
}
pub static TWEAK_WIDGETS: LazyLock<HashMap<TweakId, TweakWidget>> = LazyLock::new(|| {
    let mut map = HashMap::new();
    map.insert(TweakId::LargeSystemCache, TweakWidget::Switch);
    map.insert(TweakId::SystemResponsiveness, TweakWidget::Switch);
    map.insert(TweakId::DisableHWAcceleration, TweakWidget::Switch);
    map.insert(TweakId::Win32PrioritySeparation, TweakWidget::Switch);
    map.insert(TweakId::DisableCoreParking, TweakWidget::Switch);
    map.insert(TweakId::SeLockMemoryPrivilege, TweakWidget::Switch);
    map.insert(TweakId::UltimatePerformancePlan, TweakWidget::Switch);
    map
});
```

```rust
// src/widgets/switch.rs

use egui::{self, Color32, Pos2, Response, Rounding, Sense, Stroke, Ui, Vec2, Widget};

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ToggleSwitchState {
    Off,
    InProgress,
    On,
}

#[derive(Clone, Copy, Debug)]
pub struct ToggleSwitch {
    pub state: ToggleSwitchState,
    stroke_color: Stroke,
    rounding: Rounding,
    min_size: Vec2,
}

impl Default for ToggleSwitch {
    fn default() -> Self {
        Self::new(ToggleSwitchState::Off)
    }
}

impl ToggleSwitch {
    pub fn new(state: ToggleSwitchState) -> Self {
        Self {
            state,
            stroke_color: Stroke::new(1.0, Color32::BLACK),
            rounding: Rounding::same(15.0),
            min_size: Vec2::new(60.0, 30.0),
        }
    }

    pub fn fill_color(&self) -> Color32 {
        match self.state {
            ToggleSwitchState::Off => Color32::from_rgb(200, 200, 200),
            ToggleSwitchState::InProgress => Color32::from_rgb(100, 150, 250),
            ToggleSwitchState::On => Color32::from_rgb(100, 200, 100),
        }
    }
}

impl Widget for ToggleSwitch {
    fn ui(self, ui: &mut Ui) -> Response {
        let is_clickable = matches!(self.state, ToggleSwitchState::Off | ToggleSwitchState::On);

        let sense = if is_clickable {
            Sense::click()
        } else {
            Sense::hover()
        };

        let (rect, mut response) = ui.allocate_exact_size(self.min_size, sense);

        if is_clickable && response.clicked() {
            response.mark_changed();
        }

        response.widget_info(|| {
            egui::WidgetInfo::selected(egui::WidgetType::Checkbox, ui.is_enabled(), false, "")
        });

        if ui.is_rect_visible(rect) {
            let visuals = ui.style().interact(&response);
            let expanded_rect = rect.expand(visuals.expansion);
            let radius = 0.5 * rect.height();

            // Draw the background rectangle
            ui.painter().rect(
                expanded_rect,
                self.rounding,
                self.fill_color(),
                self.stroke_color,
            );

            // Position of the toggle circle
            let circle_pos = match self.state {
                ToggleSwitchState::Off => Pos2::new(rect.left() + radius, rect.center().y),
                ToggleSwitchState::InProgress => rect.center(),
                ToggleSwitchState::On => Pos2::new(rect.right() - radius, rect.center().y),
            };

            // Circle fill color
            let circle_fill = Color32::WHITE;

            // Draw the toggle circle
            ui.painter()
                .circle(circle_pos, 0.75 * radius, circle_fill, visuals.fg_stroke);
        }

        response
    }
}
```


Can you finish implementing main.rs and worker.rs? Use modular design, with unique functions/methods for each step of the process.